
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>R for Environmental and Resource Economists</title>
    
    <meta name="author" content="Taro Mieno">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">

    <link rel="alternate" type="application/atom+xml" title="R Entries" href="/atom.xml" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter-2.0/css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css" media="screen">
      body {
        padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */
      }
    </style>
    <link href="/assets/themes/twitter-2.0/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter-2.0/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter-2.0/css/syntax.css" rel="stylesheet" type="text/css">

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="/figs/favicon.ico">
  <!-- Update these with your own images
    <link rel="apple-touch-icon" href="/figs/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/figs/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/figs/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">Taro Mieno</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="/categories.html">Categories</a></li>
              <li><a href="/archive.html">Archive</a></li>
              <li><a href="/about.html">About</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>R for Environmental and Resource Economists </h1>
</div>

<div class="row">
  <div class="span12">
    
   <!-- here add you post markup -->
   <h1><a href="/r/spatial/2015/08/10/buffer">Identifying spatial points within a Buffer of spatial objects</a></h1>
   <p class="author">
    <span class="date">2015-08-10</span>
  </p>
  <div class="content">
    <!-- -->

<hr />

<p>Spatial discontinuity sometimes allows for a clean impact evaluation. For example, Balck (1999) made use of the fact that school districts strictly determine which school kids may enter to evaluate the value of school quality, reflected on the housing price.
Housing prices are heavily dependent on spatial heterogeneous characteristics, such as, crime rate and the distance to a park, etc. One way to control for these spatial variables that are sometimes unobservables (thus often cause omitted variable bias) is to compare houses that are very close to the border that separates one side from the other. In this post, I will show you how to identify spatial observation units (in this example, they are irrigation wells in Nebraska) that are within the buffer around such a border.</p>

<p>First, let’s load packages we are going to use in this session.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="kn">library</span><span class="p">(</span>rgdal<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>data.table<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>dplyr<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>ggplot2<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>rgeos<span class="p">)</span></code></pre></div>

<p><br /></p>

<p>Let’s now import a data set of wells located within the Upper and Middle Republican Natural Resources Districts (URNRD and MRNRD, respectively).</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">wells <span class="o">&lt;-</span> fread<span class="p">(</span><span class="s">&#39;wells_urmr.csv&#39;</span><span class="p">)</span></code></pre></div>

<p><br /></p>

<p>We also import a shape file of county boundaries for Nebraska and then subset it to have only Chase, Dundy, Perkins, Lincoln, Hayes, and Hitchcock County. We then give a status of “urnrd” to wells located within either one of Chase, Dundy, and Perkins County and “mrnrd” to the rest.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">NE_county <span class="o">&lt;-</span> readOGR<span class="p">(</span>dsn <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="s">&quot;county_bound&quot;</span><span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## OGR data source with driver: ESRI Shapefile 
## Source: &quot;.&quot;, layer: &quot;county_bound&quot;
## with 93 features
## It has 26 fields</code></pre></div>

<div class="highlight"><pre><code class="language-r" data-lang="r">um_county <span class="o">&lt;-</span> NE_county<span class="p">[</span>NE_county<span class="o">@</span>data<span class="o">$</span>COUNTY_NAM <span class="o">%in%</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;CHASE&#39;</span><span class="p">,</span> <span class="s">&#39;DUNDY&#39;</span><span class="p">,</span> <span class="s">&#39;PERKINS&#39;</span><span class="p">,</span><span class="s">&#39;LINCOLN&#39;</span><span class="p">,</span> <span class="s">&#39;HAYES&#39;</span><span class="p">,</span> <span class="s">&#39;HITCHCOCK&#39;</span><span class="p">),]</span>
um_county<span class="o">@</span>data<span class="o">$</span>nrd <span class="o">&lt;-</span> <span class="s">&#39;mrnrd&#39;</span>
um_county<span class="o">@</span>data<span class="p">[</span>um_county<span class="o">@</span>data<span class="o">$</span>COUNTY_NAM <span class="o">%in%</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;CHASE&#39;</span><span class="p">,</span> <span class="s">&#39;DUNDY&#39;</span><span class="p">,</span> <span class="s">&#39;PERKINS&#39;</span><span class="p">),</span><span class="s">&#39;nrd&#39;</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="s">&#39;urnrd&#39;</span></code></pre></div>

<p><br /></p>

<p>Here is the map of wells:</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">um_county_f <span class="o">&lt;-</span> fortify<span class="p">(</span>um_county<span class="p">,</span>region <span class="o">=</span> <span class="s">&quot;COUNTY_NAM&quot;</span><span class="p">)</span> <span class="o">%&gt;%</span> data.table<span class="p">()</span>
g_wells <span class="o">&lt;-</span> ggplot<span class="p">(</span>data<span class="o">=</span>wells<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">))</span> <span class="o">+</span> 
	geom_point<span class="p">(</span>colour<span class="o">=</span><span class="s">&#39;orange&#39;</span><span class="p">,</span>size<span class="o">=</span><span class="m">0.7</span><span class="p">)</span> <span class="o">+</span>
	coord_equal<span class="p">(</span>ratio<span class="o">=</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span>
  	labs<span class="p">(</span>x<span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> y<span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="c1">#labels</span>
  	theme<span class="p">(</span>
  		axis.ticks.y <span class="o">=</span> element_blank<span class="p">(),</span>
  		axis.text.y <span class="o">=</span> element_blank<span class="p">(),</span> <span class="c1"># get rid of x ticks/text</span>
  		axis.ticks.x <span class="o">=</span> element_blank<span class="p">(),</span>
  		axis.text.x <span class="o">=</span> element_blank<span class="p">(),</span>
  		panel.background <span class="o">=</span> element_rect<span class="p">(</span>fill<span class="o">=</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
  	<span class="p">)</span>

g_with_bound <span class="o">&lt;-</span> g_wells <span class="o">+</span> 
	geom_polygon<span class="p">(</span>data<span class="o">=</span>um_county_f<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">,</span>group<span class="o">=</span>group<span class="p">),</span>fill<span class="o">=</span><span class="kc">NA</span><span class="p">,</span>colour<span class="o">=</span><span class="s">&quot;black&quot;</span><span class="p">,</span>size<span class="o">=</span><span class="m">0.5</span><span class="p">)</span> 

g_with_bound</code></pre></div>

<p><img src="/images/buffer-worldmap-1.png" alt="plot of chunk worldmap" /></p>

<p><br /></p>

<p>The objective here is to find wells that are close to the border that separates URNRD and MRNRD, which is the vertical (almost) line that separates all the counties into 3 to the west and 3 to the east. Since we are not interested in the horizontal borders, let’s dissolve the URNRD and MRNRD counties individually using the <strong>gUnaryUnion( )</strong> function from the <strong>rgeos</strong> package.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">u_to_m <span class="o">&lt;-</span> gUnaryUnion<span class="p">(</span>um_county<span class="p">,</span> um_county<span class="o">@</span>data<span class="o">$</span>nrd<span class="p">)</span></code></pre></div>

<p><br /></p>

<p>Now the map looks like this:</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">u_to_m_f <span class="o">&lt;-</span> fortify<span class="p">(</span>u_to_m<span class="p">,</span>region<span class="o">=</span><span class="s">&#39;nrd&#39;</span><span class="p">)</span>
g_with_dis <span class="o">&lt;-</span> g_wells <span class="o">+</span>
	geom_polygon<span class="p">(</span>data<span class="o">=</span>u_to_m_f<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">,</span>group<span class="o">=</span>group<span class="p">),</span>fill<span class="o">=</span><span class="kc">NA</span><span class="p">,</span>colour<span class="o">=</span><span class="s">&quot;black&quot;</span><span class="p">)</span>
g_with_dis</code></pre></div>

<p><img src="/images/buffer-show1-1.png" alt="plot of chunk show1" /></p>

<p><br /></p>

<p>Now, let’s create buffers around the borders using the <strong>gBuffer( )</strong> function from the <strong>rgeos</strong> package. You can see the red lines that are off by “20000” from the border of URNRD and MRNRD.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">buf_nrd <span class="o">&lt;-</span> gBuffer<span class="p">(</span>u_to_m<span class="p">,</span>width<span class="o">=</span><span class="m">20000</span><span class="p">,</span>byid<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
plot<span class="p">(</span>buf_nrd<span class="p">,</span> border <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
plot<span class="p">(</span>u_to_m<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span></code></pre></div>

<p><img src="/images/buffer-buffer-1.png" alt="plot of chunk buffer" /> 
<br /></p>

<p>Finding the intersection of the two buffers (red-shaded region) using <strong>gIntersection( )</strong> gives us almost what we want.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">buf_int <span class="o">&lt;-</span> gIntersection<span class="p">(</span>buf_nrd<span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="p">],</span> buf_nrd<span class="p">[</span><span class="m">2</span><span class="p">,</span> <span class="p">])</span> 
plot<span class="p">(</span>buf_nrd<span class="p">,</span> border <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
plot<span class="p">(</span>u_to_m<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
plot<span class="p">(</span>buf_int<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;#FF000080&quot;</span><span class="p">)</span></code></pre></div>

<p><img src="/images/buffer-buffer_int-1.png" alt="plot of chunk buffer_int" /></p>

<p><br /></p>

<p>The problem is of course that the intersection includes area that does not belong to either URNRD or MRNRD. So, let’s cut out those regions.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">buf <span class="o">&lt;-</span> gIntersection<span class="p">(</span>buf_int<span class="p">,</span> gUnaryUnion<span class="p">(</span>u_to_m<span class="p">))</span>
plot<span class="p">(</span>buf_nrd<span class="p">,</span> border <span class="o">=</span> <span class="s">&quot;red&quot;</span><span class="p">)</span>
plot<span class="p">(</span>u_to_m<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">)</span>
plot<span class="p">(</span>buf<span class="p">,</span> add <span class="o">=</span> <span class="kc">TRUE</span><span class="p">,</span> col <span class="o">=</span> <span class="s">&quot;#FF000080&quot;</span><span class="p">)</span></code></pre></div>

<p><img src="/images/buffer-final-1.png" alt="plot of chunk final" /></p>

<p><br /></p>

<p>Great. So, we’ve successfully created the buffer we want. The next step is to identify spatial points (wells) that are located within the buffer. This can be achieved easily with the <strong>over( )</strong> function.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">#--- create a SpatialPointsDataFrame of wells ---#</span>
wells_spatial <span class="o">&lt;-</span> SpatialPointsDataFrame<span class="p">(</span>coords<span class="o">=</span>wells<span class="p">[,</span><span class="kt">list</span><span class="p">(</span>long<span class="p">,</span>lat<span class="p">)],</span> data<span class="o">=</span>wells<span class="p">)</span>

<span class="c1">#--- same projection scheme ---#</span>
proj4string<span class="p">(</span>wells_spatial<span class="p">)</span> <span class="o">&lt;-</span> buf<span class="o">@</span>proj4string

<span class="c1">#--- which wells in the buffer? ---#</span>
within <span class="o">&lt;-</span> over<span class="p">(</span>wells_spatial<span class="p">,</span>buf<span class="p">)</span>
id_within <span class="o">&lt;-</span> <span class="kp">cbind</span><span class="p">(</span>wells<span class="p">[,</span><span class="kt">list</span><span class="p">(</span>id<span class="p">)],</span><span class="kp">within</span><span class="p">)[</span><span class="o">!</span><span class="kp">is.na</span><span class="p">(</span><span class="kp">within</span><span class="p">),</span>id<span class="p">]</span> 

<span class="c1">#--- select wells that are within the buffer ---#</span>
wells_within <span class="o">&lt;-</span> wells<span class="p">[</span>id <span class="o">%in%</span> id_within<span class="p">,]</span></code></pre></div>

<p><br /></p>

<p>Let’s confirm if what we’ve done is correct by looking at a map:</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">buf_f <span class="o">&lt;-</span> fortify<span class="p">(</span>buf<span class="p">)</span> <span class="o">%&gt;%</span> data.table<span class="p">()</span>
g_with_bound <span class="o">+</span>
	geom_polygon<span class="p">(</span>data<span class="o">=</span>buf_f<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">,</span>group<span class="o">=</span>group<span class="p">),</span>fill<span class="o">=</span><span class="s">&quot;#FF000080&quot;</span><span class="p">,</span>alpha<span class="o">=</span><span class="m">0.4</span><span class="p">)</span> <span class="o">+</span>
	geom_point<span class="p">(</span>data<span class="o">=</span>wells_within<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">),</span>colour<span class="o">=</span><span class="s">&#39;blue&#39;</span><span class="p">,</span>size<span class="o">=</span><span class="m">0.7</span><span class="p">)</span></code></pre></div>

<p><img src="/images/buffer-final_map-1.png" alt="plot of chunk final_map" /></p>

<p>Looking good. This is it for this post. Enjoy!</p>

<p><br />
<br /></p>

<h3 id="session-information">Session Information</h3>

<hr />

<div class="highlight"><pre><code class="language-text" data-lang="text">## R version 3.2.0 (2015-04-16)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.10 (Yosemite)
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] methods   stats     graphics  grDevices utils     datasets  base     
## 
## other attached packages:
## [1] maptools_0.8-36  rgeos_0.3-11     ggplot2_1.0.1    dplyr_0.4.2     
## [5] data.table_1.9.4 rgdal_1.0-4      sp_1.1-1         knitr_1.10.5    
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.0      magrittr_1.5     MASS_7.3-43      munsell_0.4.2   
##  [5] colorspace_1.2-6 lattice_0.20-33  R6_2.1.0         stringr_1.0.0   
##  [9] plyr_1.8.3       tools_3.2.0      parallel_3.2.0   grid_3.2.0      
## [13] gtable_0.1.2     DBI_0.3.1        assertthat_0.1   digest_0.6.8    
## [17] reshape2_1.4.1   formatR_1.2      evaluate_0.7     labeling_0.3    
## [21] stringi_0.5-5    scales_0.2.5     foreign_0.8-65   chron_2.3-47    
## [25] proto_0.3-10</code></pre></div>

<p><br />
<br /></p>

<h3 id="references">References</h3>

<hr />

<p><span id="black99">Black, S. E. (1999). Do better schools matter? Parental valuation of elementary education. <i>Quarterly Journal of Economics</i>, 577–599.</span></p>


  </div>

   <!-- here add you post markup -->
   <h1><a href="/r/spatial/2015/08/08/square_grid">Creating square grid dummy variables for regression analysis</a></h1>
   <p class="author">
    <span class="date">2015-08-08</span>
  </p>
  <div class="content">
    <!-- -->

<hr />

<p>In the course of my work on the estimation of the impacts of brownfields cleanup on housing prices in NY, I used 0.25- by 0.25-mile square grid fixed effects, which have a tighter control on unobservable neighbor characteristics than census tract fixed effects. The use of square grid fixed effects originate from Linn (2013). In this post, I will show you how I created the square grid dummy variables. Specifically, we’ll learn to:</p>

<ol>
  <li>Create a raster layer consisting of square grids that covers five counties in NY: Bronx, Queens, Kings, New York, and Richmond.
    <ul>
      <li>identify how many miles one latitude and longitude degrees are, respectively</li>
      <li>identify the bounding box</li>
      <li>identify the number of rows and columns of the final layer</li>
      <li>create a SpatialGridDataFrame from scratch based on the information from the previous steps</li>
    </ul>
  </li>
  <li>Overlay point data (property locations) on the grids to identify which property belongs to which grid.</li>
</ol>

<p>Let’s first load the packages we are going to use in this session.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="kn">library</span><span class="p">(</span>knitr<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>rgdal<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>data.table<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>dplyr<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>ggplot2<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>raster<span class="p">)</span></code></pre></div>

<p><br /></p>

<p>Now, we need to know the geographic extent of the three states in order to see how many miles one latitude and longitude degrees are, respectively. One latitude degree is similar in distance from the south to north end of the globe and is equivalent to 69 miles more or less. On the other hand, one latitude degree means a very different distance depending on where you are. One longitude degree is the longest at the equator and is about 69 miles. However, as you go farther away from the equator, one longitude degree means a smaller distance. So, if we would like to create square grids, we need to know the conversion rate at the geographic extent of our interest. You can find this information <a href="http://www.csgnetwork.com/degreelenllavcalc.html">here</a>. At latitude of 41, 1 latitude degree = 69.01 miles and 1 longitude degree = 52.28 miles. As we would like to create 0.25- by 0.25-mile square grids, the step sizes (distance between the centroids of adjacent grids) are the following:</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">lat_step_size <span class="o">&lt;-</span>	<span class="m">1</span><span class="o">/</span><span class="m">69.01</span><span class="o">/</span><span class="m">4</span>
lon_step_size <span class="o">&lt;-</span>	<span class="m">1</span><span class="o">/</span><span class="m">52.28</span><span class="o">/</span><span class="m">4</span></code></pre></div>

<p><br /></p>

<p>Now, let’s import a NY county shape file (can be downloaded from <a href="http://www.arcgis.com/home/item.html?id=7f4850fb7d18496ca6925f209d2d1275">here</a>) using <strong>readOGR( )</strong> that comes with the <strong>rgdal</strong> package.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">ny_state <span class="o">&lt;-</span> readOGR<span class="p">(</span>dsn <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="s">&quot;NY_counties_clip&quot;</span><span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## OGR data source with driver: ESRI Shapefile 
## Source: &quot;.&quot;, layer: &quot;NY_counties_clip&quot;
## with 62 features
## It has 20 fields</code></pre></div>

<p><br /></p>

<p>We then generate a subset of the SpatialPolygonDataFrame to contain only Bronx, Queens, Kings, New York, and Richmond counties.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">counties <span class="o">&lt;-</span> ny_state<span class="p">[</span>ny_state<span class="o">@</span>data<span class="o">$</span>NAME <span class="o">%in%</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;Bronx&#39;</span><span class="p">,</span><span class="s">&#39;Queens&#39;</span><span class="p">,</span><span class="s">&#39;Kings&#39;</span><span class="p">,</span><span class="s">&#39;New York&#39;</span><span class="p">,</span><span class="s">&#39;Richmond&#39;</span><span class="p">),]</span></code></pre></div>

<p><br /></p>

<p>To get the spatial extent of these counties, we can extract this information from the <strong>bbox</strong> slot of <strong>counties</strong>.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">counties<span class="o">@</span>bbox</code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">##         min       max
## x -74.23694 -73.70027
## y  40.50600  40.91595</code></pre></div>

<p><br /></p>

<p>Using this information, we define the geographic coordinate of the lower left corner of the gridded layer and its number of rows and columns. We then feed these information into the <strong>GridTopology( )</strong> function to create a SpatialGridDataFrame consisting of 0.25- by 0.25- mile grids.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="c1">#--- latitude ---#</span>
left_lon <span class="o">&lt;-</span> counties<span class="o">@</span>bbox<span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="m">-0.01</span>
num_col <span class="o">&lt;-</span> <span class="kp">ceiling</span><span class="p">((</span>counties<span class="o">@</span>bbox<span class="p">[</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">-</span>left_lon<span class="p">)</span><span class="o">/</span>lat_step_size<span class="p">)</span>

<span class="c1">#--- longitude ---#</span>
down_lat <span class="o">&lt;-</span> counties<span class="o">@</span>bbox<span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="m">1</span><span class="p">]</span><span class="m">-0.01</span>
num_row <span class="o">&lt;-</span> <span class="kp">ceiling</span><span class="p">((</span>counties<span class="o">@</span>bbox<span class="p">[</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">-</span>down_lat<span class="p">)</span><span class="o">/</span>lon_step_size<span class="p">)</span>

<span class="c1">#--- create SpatialGridDataFrame ---#</span>
gt <span class="o">&lt;-</span> GridTopology<span class="p">(</span><span class="kt">c</span><span class="p">(</span>left_lon<span class="p">,</span>down_lat<span class="p">),</span><span class="kt">c</span><span class="p">(</span>lon_step_size<span class="p">,</span>lat_step_size<span class="p">),</span><span class="kt">c</span><span class="p">(</span>num_row<span class="p">,</span>num_col<span class="p">))</span>
spg <span class="o">&lt;-</span> SpatialGrid<span class="p">(</span>gt<span class="p">)</span>
ny_grids <span class="o">&lt;-</span> SpatialGridDataFrame<span class="p">(</span>spg<span class="p">,</span> data.table<span class="p">(</span>id <span class="o">=</span> <span class="m">1</span><span class="o">:</span><span class="p">(</span>num_col<span class="o">*</span>num_row<span class="p">)))</span></code></pre></div>

<p><br /></p>

<p>Now, let’s import fake property location data that I created. We then use the <strong>coordinates( )</strong> function to transform the data into a SpatialPointsDataFrame.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">prop <span class="o">&lt;-</span> fread<span class="p">(</span><span class="s">&#39;fake_poperty.csv&#39;</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>prop<span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">##         lat       lon prop_id
## 1: 40.80627 -73.92422       1
## 2: 40.80561 -73.92262       2
## 3: 40.80981 -73.92068       3
## 4: 40.81193 -73.91994       4
## 5: 40.81169 -73.91904       5
## 6: 40.81255 -73.91737       6</code></pre></div>

<div class="highlight"><pre><code class="language-r" data-lang="r">coordinates<span class="p">(</span>prop<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;lon&#39;</span><span class="p">,</span><span class="s">&#39;lat&#39;</span><span class="p">)</span>
prop</code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## class       : SpatialPointsDataFrame 
## features    : 10000 
## extent      : -74.25467, -73.70042, 40.49932, 40.91101  (xmin, xmax, ymin, ymax)
## coord. ref. : NA 
## variables   : 1
## names       : prop_id 
## min values  :       1 
## max values  :   10000</code></pre></div>

<p><br /></p>

<p>To identify which property falls within which grid cell in the gridded layer created above, we use the <strong>over( )</strong> function.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">which_poly <span class="o">&lt;-</span> over<span class="p">(</span>prop<span class="p">,</span>ny_grids<span class="p">)</span> <span class="o">%&gt;%</span> data.table<span class="p">()</span>
which_poly <span class="o">&lt;-</span> <span class="kp">cbind</span><span class="p">(</span>prop<span class="o">@</span>data<span class="o">$</span>prop_id<span class="p">,</span>which_poly<span class="p">)</span>
setnames<span class="p">(</span>which_poly<span class="p">,</span><span class="kp">names</span><span class="p">(</span>which_poly<span class="p">),</span><span class="kt">c</span><span class="p">(</span><span class="s">&#39;pid&#39;</span><span class="p">,</span><span class="s">&#39;grid_id&#39;</span><span class="p">))</span>
which_poly</code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">##          pid grid_id
##     1:     1    5700
##     2:     2    5789
##     3:     3    5613
##     4:     4    5613
##     5:     5    5614
##    ---              
##  9996:  9996    9121
##  9997:  9997    8603
##  9998:  9998    8969
##  9999:  9999    9707
## 10000: 10000    9893</code></pre></div>

<p><br /></p>

<p>You can see that each property is assigned a unique grid id value. Now you can use this information to create grid dummies or grid-year dummies to implement estimation similar to those done in @linn13.</p>

<p><br />
<br /></p>

<h2 id="session-information">Session Information</h2>

<hr />

<div class="highlight"><pre><code class="language-text" data-lang="text">## R version 3.2.0 (2015-04-16)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.10 (Yosemite)
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] methods   stats     graphics  grDevices utils     datasets  base     
## 
## other attached packages:
## [1] raster_2.4-15    ggplot2_1.0.1    dplyr_0.4.2      data.table_1.9.4
## [5] rgdal_1.0-4      sp_1.1-1         knitr_1.10.5    
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.0      magrittr_1.5     MASS_7.3-43      munsell_0.4.2   
##  [5] colorspace_1.2-6 lattice_0.20-33  R6_2.1.0         stringr_1.0.0   
##  [9] plyr_1.8.3       tools_3.2.0      parallel_3.2.0   grid_3.2.0      
## [13] gtable_0.1.2     DBI_0.3.1        assertthat_0.1   digest_0.6.8    
## [17] reshape2_1.4.1   formatR_1.2      evaluate_0.7     stringi_0.5-5   
## [21] scales_0.2.5     chron_2.3-47     proto_0.3-10</code></pre></div>

<p><br />
<br /></p>

<h2 id="references">References</h2>

<hr />

<p><span id="linn13">Linn, J. (2013). The effect of voluntary brownfields programs on nearby property values: Evidence from Illinois. <i>Journal Of Urban Economics</i>, <i>78</i>, 1–18.</span></p>

  </div>

   <!-- here add you post markup -->
   <h1><a href="/r/spatial/2015/08/08/map_introduction">Mapping point data on polygons using gplot2( )</a></h1>
   <p class="author">
    <span class="date">2015-08-08</span>
  </p>
  <div class="content">
    
<hr />

<p>In this post, I will show how to make a map of spatial points data (irrigation wells) overlayed on spatial polygons (counties in Nebraska) using <strong>ggplot( )</strong>. You will learn:</p>

<ul>
  <li>
    <p>how to transform a SpatialPolygonDataFrame into a data frame that is compatible with <strong>ggplot( )</strong> for mapping using the <strong>fortify( )</strong> function from the <strong>ggplot2</strong> package</p>
  </li>
  <li>
    <p>change the coordinate reference system (CRS) using <strong>spTransform( )</strong> from the <strong>sp</strong> package.</p>
  </li>
  <li>
    <p>create a map of points data overlayed on spatial polygons.</p>
  </li>
</ul>

<p>Let’s first load packages we are going to use in this session.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r"><span class="kn">library</span><span class="p">(</span>rgdal<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>data.table<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>dplyr<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>ggplot2<span class="p">)</span>
<span class="kn">library</span><span class="p">(</span>raster<span class="p">)</span></code></pre></div>

<p><br /></p>

<p>We now import a Nebraska county shape file and select Chase, Dundy, and Perkins counties.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">NE_county <span class="o">&lt;-</span> readOGR<span class="p">(</span>dsn <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="s">&quot;county_bound&quot;</span><span class="p">)</span>
urnrd <span class="o">&lt;-</span> NE_county<span class="p">[</span>NE_county<span class="o">@</span>data<span class="o">$</span>COUNTY_NAM <span class="o">%in%</span> <span class="kt">c</span><span class="p">(</span><span class="s">&quot;CHASE&quot;</span><span class="p">,</span><span class="s">&quot;DUNDY&quot;</span><span class="p">,</span><span class="s">&quot;PERKINS&quot;</span><span class="p">),]</span></code></pre></div>

<p><br /></p>

<p>Unfortunately, a SpatialPolygonDataFrame cannot be used immediately for mapping using <strong>ggplot( )</strong>. The ggplot2 package, however, offers a function called <strong>fortify( )</strong>, which transforms a SpatialPolygonDataFrame into a data frame that is compatible with mapping using <strong>ggplot( )</strong>.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">urnrd_f <span class="o">&lt;-</span> fortify<span class="p">(</span>urnrd<span class="p">,</span> region <span class="o">=</span> <span class="s">&quot;COUNTY_NAM&quot;</span><span class="p">)</span>
<span class="kp">head</span><span class="p">(</span>urnrd_f<span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">##      long      lat order  hole piece   group    id
## 1 1083135 321605.2     1 FALSE     1 CHASE.1 CHASE
## 2 1083251 321603.6     2 FALSE     1 CHASE.1 CHASE
## 3 1083535 321599.5     3 FALSE     1 CHASE.1 CHASE
## 4 1083555 321599.4     4 FALSE     1 CHASE.1 CHASE
## 5 1084352 321588.2     5 FALSE     1 CHASE.1 CHASE
## 6 1084828 321573.1     6 FALSE     1 CHASE.1 CHASE</code></pre></div>

<p><br /></p>

<p>Now, you may have noticed that in the urnrd_f dataset, variables long and lat have values that cannot possibly be right as valid longitude and latitude. This is because the original shape file of Nebraska counties uses a different geographical representation of locations than longitude and latitude. You can see this by using <strong>proj4string( )</strong> function.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">proj4string<span class="p">(</span>urnrd<span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## [1] &quot;+proj=lcc +lat_1=40 +lat_2=43 +lat_0=39.83333333333334 +lon_0=-100 +x_0=500000.0000000001 +y_0=0 +datum=NAD83 +units=us-ft +no_defs +ellps=GRS80 +towgs84=0,0,0&quot;</code></pre></div>

<p><br /></p>

<p>It turns out the Lambert conformal conic (lcc) projection method is used in this dataset as you can see from “+proj=lcc” in the output. On the other hand, the location of irrigation wells is represented simply by longitude and latitude, unprojected.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">wells <span class="o">&lt;-</span> fread<span class="p">(</span><span class="s">&#39;fake_wells.csv&#39;</span><span class="p">)</span>
wells</code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">##            lat      long      gpm
##    1: 40.54449 -101.8650 817.9014
##    2: 40.49558 -101.3700 953.2952
##    3: 40.47911 -101.9014 934.3472
##    4: 40.61308 -101.9029 752.5348
##    5: 40.38938 -101.9422 856.6183
##   ---                            
## 2918: 40.87906 -101.9236 692.4241
## 2919: 40.55861 -101.7935 687.3473
## 2920: 40.80561 -101.5178 603.0804
## 2921: 40.32196 -101.6708 745.0353
## 2922: 40.09223 -101.4382 236.5328</code></pre></div>

<p><br /></p>

<p>As you can imagine, in order for <strong>ggplot( )</strong> to correctly map both  counties and wells on a single map, they should have the same coordinate reference system (CRS). To do this, let’s first transform the well data into a SpatialPointsDataFrame by using the <strong>coordinates( )</strong> function.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">coordinates<span class="p">(</span>wells<span class="p">)</span> <span class="o">&lt;-</span> <span class="kt">c</span><span class="p">(</span><span class="s">&#39;long&#39;</span><span class="p">,</span><span class="s">&#39;lat&#39;</span><span class="p">)</span>
proj4string<span class="p">(</span>wells<span class="p">)</span></code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## [1] NA</code></pre></div>

<p><br /></p>

<p>As you can see above, the CRS has not been declared for the wells data at this point. So, let’s define one for the wells.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">proj4string<span class="p">(</span>wells<span class="p">)</span> <span class="o">&lt;-</span>  CRS<span class="p">(</span><span class="s">&quot;+proj=longlat&quot;</span><span class="p">)</span></code></pre></div>

<p><br /></p>

<p>Now, we can use <strong>spTransform( )</strong> to change the CRS of wells to that of urnrd_f.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">wells_lcc <span class="o">&lt;-</span> spTransform<span class="p">(</span>wells<span class="p">,</span> urnrd<span class="o">@</span>proj4string<span class="p">)</span>
wells_lcc</code></pre></div>

<div class="highlight"><pre><code class="language-text" data-lang="text">## class       : SpatialPointsDataFrame 
## features    : 2922 
## extent      : 1067358, 1295641, 66445.43, 431259.7  (xmin, xmax, ymin, ymax)
## coord. ref. : +proj=lcc +lat_1=40 +lat_2=43 +lat_0=39.83333333333334 +lon_0=-100 +x_0=500000.0000000001 +y_0=0 +datum=NAD83 +units=us-ft +no_defs +ellps=GRS80 +towgs84=0,0,0 
## variables   : 1
## names       :              gpm 
## min values  :                0 
## max values  : 1378.17256086539</code></pre></div>

<p><br /></p>

<p>You can see that wells now have the same CRS as county boundaries. As we only want a data frame of coordinates for mapping instead of a SpatialPointsDataFrame,</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">wells_to_map <span class="o">&lt;-</span> wells_lcc<span class="o">@</span>coords <span class="o">%&gt;%</span> data.table<span class="p">()</span></code></pre></div>

<p><br /></p>

<p>With all the data at our fingertips, let’s create a map! Here is the map of selected counties in Nebraska.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">map <span class="o">&lt;-</span> ggplot<span class="p">(</span>urnrd_f<span class="p">,</span> aes<span class="p">(</span>long<span class="p">,</span> lat<span class="p">))</span> <span class="o">+</span> 
 geom_polygon<span class="p">(</span>aes<span class="p">(</span>group<span class="o">=</span>group<span class="p">),</span>fill<span class="o">=</span><span class="s">&quot;#D3D3D3&quot;</span><span class="p">,</span>colour<span class="o">=</span><span class="s">&quot;black&quot;</span><span class="p">,</span>size<span class="o">=</span><span class="m">0.2</span><span class="p">)</span> <span class="o">+</span>
 coord_equal<span class="p">(</span>ratio<span class="o">=</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span>
 labs<span class="p">(</span>x<span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">,</span> y<span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span>
 theme<span class="p">(</span>
 	axis.ticks.y <span class="o">=</span> element_blank<span class="p">(),</span>
 	axis.text.y <span class="o">=</span> element_blank<span class="p">(),</span> 
 	axis.ticks.x <span class="o">=</span> element_blank<span class="p">(),</span>
 	axis.text.x <span class="o">=</span> element_blank<span class="p">(),</span>
 	panel.background <span class="o">=</span> element_rect<span class="p">(</span>fill<span class="o">=</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
 	<span class="p">)</span></code></pre></div>

<p><img src="/images/spatial_map-unnamed-chunk-1-1.png" alt="plot of chunk unnamed-chunk-1" /></p>

<p><br /></p>

<p>Now, let’s add wells onto this map.</p>

<div class="highlight"><pre><code class="language-r" data-lang="r">map <span class="o">&lt;-</span> map <span class="o">+</span> 
	geom_point<span class="p">(</span>data<span class="o">=</span>wells_to_map<span class="p">,</span>aes<span class="p">(</span>x<span class="o">=</span>long<span class="p">,</span>y<span class="o">=</span>lat<span class="p">),</span>size<span class="o">=</span><span class="m">0.7</span><span class="p">)</span></code></pre></div>

<p><img src="/images/spatial_map-disp-1.png" alt="plot of chunk disp" /></p>

<p><br />
<br /></p>

<h3 id="session-information">Session Information</h3>

<hr />

<div class="highlight"><pre><code class="language-text" data-lang="text">## R version 3.2.0 (2015-04-16)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.10 (Yosemite)
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] methods   stats     graphics  grDevices utils     datasets  base     
## 
## other attached packages:
## [1] maptools_0.8-36  raster_2.4-15    ggplot2_1.0.1    dplyr_0.4.2     
## [5] data.table_1.9.4 rgdal_1.0-4      sp_1.1-1         knitr_1.10.5    
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.0      magrittr_1.5     MASS_7.3-43      munsell_0.4.2   
##  [5] colorspace_1.2-6 lattice_0.20-33  R6_2.1.0         stringr_1.0.0   
##  [9] plyr_1.8.3       tools_3.2.0      parallel_3.2.0   grid_3.2.0      
## [13] gtable_0.1.2     DBI_0.3.1        rgeos_0.3-11     assertthat_0.1  
## [17] digest_0.6.8     reshape2_1.4.1   formatR_1.2      evaluate_0.7    
## [21] labeling_0.3     stringi_0.5-5    scales_0.2.5     foreign_0.8-65  
## [25] chron_2.3-47     proto_0.3-10</code></pre></div>


  </div>


<!-- Pagination links -->
<div class="pagination pagination-centered">
  <ul>
  
    
      <li class="prev"><a href="/" title="Previous page">Prev</a></li>
    
  
  
    <li class="next"><a href="/page3" title="Next page">Next</a></li>
  
  </ul>
</div>

  </div>
</div>


      </div>

      <footer>
      </footer>

    </div> <!-- /container -->

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="/assets/themes/twitter-2.0/js/jquery.min.js"><\/script>')</script>
    <script src="/assets/themes/twitter-2.0/js/bootstrap.min.js"></script>
    
  </body>
</html>

